
[CAMERA]
- Ortographic, Size: 20

[CANVAS]
- 3 paneles: Left (MinX: 0, MaxX: 0.13) / Center (MinX: 0.17, MaxX: 0.7) / Right (MinX: 0.7, MaxX: 1), todos MinY: 0, MaxY: 1
- Paneles Left y Right con un componente Image color negro y transparencia 80% (o la que queramos) para oscurecer las zonas de UI

[TEXTOS EN RIGHT PANEL]
- Arkanoid, Highscore y Score, con TextMeshPro >> lo tuneamos nosotros como queramos
- Creamos un preset (Botón Derecho > Crear > TextMeshPro > Color Gradient) y se lo asignamos a todos los textos (campo Color preset)
  De esta forma podemos cambiar el color de todos los textos al mismo tiempo

[IMPORTAR SPRITES]
- Vaus.png > Pixels per unit: 8 / Sprite mode: Multiple / Filter mode: Point (no filter)
- Walls.png > Pixels per unit: 8 / Sprite mode: Multiple / Filter mode: Point (no filter)
- Blocks.png > Pixels per unit: 8 / Sprite mode: Multiple / Filter mode: Point (no filter)
ATENCIÓN: DUPLICAMOS EL DE Walls.png y lo llamamos Backgrounds.png
- Backgrounds.png > Pixels per unit: 4 / Sprite mode: Multiple / Filter mode: Point (no filter)

Los recortamos a mano con el Sprite Editor
En el backgorund recortamos solo los claros porque el efecto oscuro ya lo hicimos nosotros en el Canvas, paneles Left y Right

Arriba a la derecha hay un botón parecido a un arco iris. Si lo pulsas pasa todo a blanco y negro,
y es más fácil ver los bordes de los sprites para recortar

[BACKGROUND]
- Gameobject con componente Sprite Renderer, Draw Mode: Tiled, Order in layer: -1 (debajo de todos), Width: 71 y Height: 40 (para que ocupe todo)

[CREAR WALLS]
- Creamos 3 walls: Top, Left y Right.
- Les ponemos un Collider2D y marcamos Auto Tiling.
- Aumentamos su tamaño hasta ocupar todos los oborder
    Top: width 39
    Left: Height 40
    Right: Height 40

[MOVIMIENTO VAUS]
- Creamos el script Vaus.cs
- Movemos el vaus con Input.GetAxis > horizontalmente
- Le ponemos un Capsule Collider2D (o un Box Collider2D)
- Le ponemos un Rigibody. Le quitamos la gravedad. Ahora ya choca contra los límites.
- Bloqueamos el movimiento en eje Y y la rotación en el eje Z.

[MOVIMIENTO BALL]
- Creamos el script Ball.cs
- Le ponemos un Rigibody. Le quitamos la gravedad.
- Le ponemos un Circle Collider2D.
- En los colliders del Ball y de los Walls asigamos el Physic Material: Bouncy (Friction: 0, Bounciness: 1), el que creamos en el Pong.
  Con esto la Ball ya va a rebotar contra los Walls y contra la Vaus.
  (NOTA: Creo que sirve con que la Ball tenga ese material, me parece que a los muros no les hace falta)
- Creamos una función Release() que le asigne una velocidad inicial: rigidbody.velocity = initialVelocity;
- IMPORTANTE:
  Ponemos la Ball como hija de la Vaus para que al principio se mueva con ella
  La Ball empieza con isKinematic = true. Por eso se mueve con la Vaus
  En el momento en que llamemos a la función Release() ponemos isKinematic = false >> ahora se aplican las físicas, ya no sigue a la Vaus
  Cuando necesitemos que la bola se vuelva a pegar a la Vaus volveremos a poner isKinematic = true, y como es hija de la Vaus volverá a moverse con ella

[WORLD MANAGER]
- Creamos el Gameobject y el script WorldManager.cs
- Creamos [SerializeField] Vaus vaus; y [SerializeField] Ball ball; y les ponemos los Asserts correspondientes.
  Ahora ya tenemos un WorlManger que está acoplado con los demás y se puede comunicar con ellos.
  De esta forma nuestros gameobjects estarán desacoplados entre ellos. Se comunicarán a través de Eventos que, en general, serán manejados por el WorldManager

[RELEASE BALL]
- Creamos en la Vaus el evento para soltar la Ball:
    if (Input.GetKeyDown(KeyCode.Space)) { OnBallReleaseEvent?.Invoke(); }
- Creamos en el WorldManager la gestión de ese evento >> escucha a la Vaus pidiendo soltar la Ball y entonces llama a la función Relese() de la Ball:
    vaus.OnBallReleaseEvent += OnBallReleaseCallback;
    private void OnBallReleaseCallback() { ball.Release(); }
- Creamos la etiqueta (tag) "Ball" y se la asignamos. La usaremos más adelante.

[CONSTANTS]
- Creamos el típico archivo de constantes
        public static string HORIZONTAL_AXIS = "Horizontal"; >> moviento
        public static string FIRE_AXIS = "Jump";

[UPDATE vs FIXED UPDATE]
- Unity RECOMIENDA manejar todos los inputs en la función Update, que se ejecuta una vez por frame
  Por esa razón ponemos ahí nuestras entradas:
    horizontalInput = Input.GetAxis(Constants.HORIZONTAL_AXIS);
    isFiredPressed = Input.GetAxis(Constants.FIRE_AXIS) != 0;
- Pero, por otro lado, Unity NO RECOMIENDA utilizar Update and FixedUpdate en el mismo script
- Posible solución: manejar todas las entradas en un script específico, y ese solo tendrá Update
  De momento nosotros lo dejamos así, con Update y FixedUpdate en el mismo frame

[BRICK]
- Creamos el script Brick.cs
- Cada ladrillo tendrá una variable que indique la puntuación, score, y otra que indique los golpes que le quedan para destruirse, resistance
- Cada vez que reciba un golpe (OnCollision) restaremos una unidad a la resistencia (de momento solo controlamos el choque contra la Ball)
- Si la resistencia llega a cero enviamos un Evento indicando que el ladrillo tiene que ser destruido
- Creamos un prefab con un Brick
- Le ponemos el tag "Brick"

[SETUP BRICKS]
- En el WorldManager creamos una lista de ladrillos: List<Brick> bricks = new List<Brick>();
- Inicializamos esa lista con todos los ladrillos de la escena, buscando por el tag "Brick"
    GameObject[] brickGOs = GameObject.FindGameObjectsWithTag("Brick");
    Como la FindGameObjectsWithTag me devuelve GameObjects y no Bricks, recorro todo el array y añado cada brick a mi lista
    Aprovecho y ahí mismo le pongo el manejador del evento a cada uno de los ladrillos: brick.OnBrickDestroyedEvent += OnBrickDestroyedCallback;
- Como ya estoy haciendo muchas cosas con ladrillos separo todo ese código en una función específica: SetupBricks()

[SCORE]
- Creamos el Gameobject Score y el script Score para llevar el control de la puntuación
- Lo ponemos como hijo de WorldManager
  (todos los managers van a ser hijos de WorldManager, aunque Score será más un "colaborador" de WorldManager que un manager en sí mismo)
- Creamos la función AddScore

[HUD MANAGER]
- HUD, Head-Up Display
- WorldManager tendrá accesor a HUD Manager (los managers hablan entre ellos)
- A1cabará siendo un Singleton porque habrá uno y solo uno, y siempre será el mismo (veremos el patrón Singleton más adelante)
- Gestiona la info que se ve en pantalla durante el juego, por eso tiene acceso al texto de Score y de Highscore

De esta forma al romper un ladrillo:
- WorldManager avisará a Score y le pasará la puntuación del ladrillo que acabamos de romper
- Score añadirá esos puntos a la puntuación total
- WorldManager le preguntará a Score la puntuación actual (es su responsabilidad)
- WorldManager le pasará esa puntuación actual a HUDManager para que la muestre por pantalla (es su responsabilidad)
>> cada elemento tiene un única responsabilidad, y será WorldManager quien los coordine a todos
>> de esa forma cumplimos el SRP, Single Responsibility Principle (la "S" de los principios SOLID)

[PLAYER MANAGER]
- Ahora cogemos el GameObject llamado "Score", lo renombramos como "PlayerManager" y lo ponemos por separado >> ya no es hijo de WorldManager
- Renombramos el script Score.cs como PlayerManager.cs
  ATENCIÓN: Siempre que hagamos esto renombramos PRIMERO en el código y luego en Unity, para que nos mantenga las referencias
- La razón de hacer esto es que WorldManager controlará cada uno de los niveles, PERO DESAPARECERÁ CUANDO PASEMOS A OTRO niveles
  Sin embargo, la puntuación y las vidas SÍ SE MANTIENEN DE UN NIVEL A OTRO
  Por necesito manejarlas con otro manager diferente que sí permanezca de un nivel a otro
- ahora desde WorldManager localizo a PlayerManager de la siquiente manera:
  playerManager = GameObject.Find("PlayerManager").GetComponent<PlayerManager>();
  No lo hago por [SerializeField] porque acabaré convirtiéndolo en Singleton, que es una clase static y por lo tanto no puede trabajar con [SerializeField]

- Le añadimos a PlayerManager el control del número de vidas que tenemos
- Si pasamos de unas puntuaciones determinadas aumentamos en uno el número de vidas